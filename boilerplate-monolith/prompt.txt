Golang ile gRPC tabanlı, yüksek performanslı ve düşük kaynak tüketen bir backend mimarisi tasarlamama yardımcı ol.
Aşağıdaki gereksinimlere göre mimari, dizin yapısı, modüller, config şeması, deployment adımları ve örnek kod üret:

– Dil: Go 1.25.5, minimum bağımlılık
– RPC: gRPC + Protocol Buffers
– Sunucu: AWS Free Tier EC2 (t2.micro / t3.micro) — düşük CPU/RAM için optimize
– Veritabanı: Supabase PostgreSQL (public internet erişimli)
– Şema: örnek ‘Product’ ve ‘Order’ tabloları
– Bağlantı: secure connection string, connection pooling, retry strategy
– API: CRUD servisleri (ProductService, OrderService)
– Repository pattern (interface + PostgreSQL implementation)
– Oturum: JWT veya supabase auth token
– Error handling: strongly typed; gRPC status codes
– Test: unit + integration (postgres + grpc)
– Deployment çıktı formatı: systemd servis dosyası + Go binary build adımları
– Ekstra: performans optimizasyonları, bellek tahsisi tavsiyeleri, goroutine yönetimi, connection reuse, zero-allocation gRPC handler örnekleri
– Son çıktı: proje klasör ağacı + her dosya için kısa örnek içerik + .proto dosyası + Dockerfile + Makefile + env örnekleri


--------------------------------------------------------------------------

Aşağıdaki “prompt şablonları” kaynak kodunu AI’a taratıp iyileştirme işi için en iyi sonucu verir.


You are a senior software engineer and performance/security reviewer.
I will paste source code in chunks. Analyze it end-to-end and propose improvements with a focus on: correctness, simplicity, maintainability, performance (CPU/memory/allocations), security, and observability.

Constraints:
- Keep behavior identical unless you explicitly justify a change.
- Prefer minimal dependencies and minimal diff.
- Point out hidden bugs, race conditions, edge cases, and error-handling issues.
- If you suggest refactors, provide a step-by-step plan and show the exact patches (diff format).
- Add/adjust tests for the changes.

Output format:
- Issues found (severity: critical/high/medium/low)
- Recommended changes (ranked by impact)
- Patch/diff
- Test additions
- Performance notes (expected wins, tradeoffs)




--------------------------------------------------------------------------





bir grpc backend servisinde aşağıdaki gibi bir yapı kullanmaktayım.
layered architecture kullanmaktayım. 
handler -> service -> repository -> database.
handler katmanıda grpc implementation ve hemen ardından request validation yapmaktayım.
iş mantığı ise tamamen service katmanına iletip dönen yanıtı yeniden handler katmanına döndürerek buradan reponse yapmaktayım.
bu akıştaki yanlışlarımı söyler misin? 
lütfen iyi analiz et, senden mükemmel bir yaklaşım önermeni benkliyorum.






Rolün: “Kıdemli Backend/Platform mimarı + Go/gRPC performans mühendisi + güvenlik ve test uzmanı” gibi davran. Nazik olma; yanlışları ve riskleri doğrudan söyle. Varsayım yapma: bilmediğin yerde net varsayımını belirt ve alternatifleri değerlendir.

Bağlam:
Ben bir gRPC backend servis boilerplate’i hazırladım. Layered architecture kullanıyorum:
handler (gRPC) -> service (iş mantığı) -> repository (DB erişimi) -> entity (domain model).

Özellikler:
- Container/Kubernetes yok, doğrudan binary çıktı alınacak ve sunucuda private 50051 portundan çalışırken dışarıdan 443 portundan erişilecek şekilde çalışacak.
- Reflection yok
- Nginx yok. 

Mevcut akışım:

- Handler katmanında gRPC implementation var ve input validation burada yapılmakta. authentication gerekiyorsa yine burada yapılmakta. Özetle handler katmanı request, input validation, proto->entity conversion, entity->proto conversion ve grpc implementation yapmaktadır. Auth, Interceptor katmanında (Middleware) merkezi olarak çözülmekte ve Context'e inject edilmekte.
- Service katmanı iş kuralları ve yetkilendirme gerekiyorsa (authorization) burada yapılmakta. Business validation burada yapılmakta. Ayrıca iş mantığı ve audit gibi işlemler burada yapılmakta. Gerektiği durumda RunInTx ile transaction burada başlatılmaktadır.
- Repository katmanı ise sadece DB erişimi yapmaktadır. Ayrıca pagination, optimistic locking, soft delete, transaction gibi işlemler burada yapılmakta. ayrıca dışa açılan RunInTx adında generic bir transaction yönetimi mevcut.
- Entity katmanı ise domain model yapmaktadır.
- Service’den dönen sonucu tekrar Handler’a alıp oradan response üretiyorum.

Bu tasarımda nerede yanlış yaptığımı ve nasıl “mükemmel” hale getireceğimi istiyorum.

Girdi:
Aşağıdaki kodları/klasör ağacını analiz edeceksin.

Kısıtlar:
- Dil: Go.
- gRPC + protobuf.
- Düşük kaynak (1GB RAM gibi) senaryolarında da iyi çalışmalı.
- Overengineering istemiyorum: “yeterince basit ama büyümeye hazır” hedefi.
- layered architecture

Başla:
Önce en riskli 10 problemi söyle, sonra önerdiğin ideal akışa göre bir refactor planı çıkar. Mümkün olduğunca somut ol: örnek interface’ler, error tipleri, interceptor zinciri, transaction sınırı nerede olmalı, mapping nerede olmalı.


grpc-highperf-backend/
├── api/
│   ├── gen/                         # protoc çıktıları (gitignore veya CI'de generate)
│   │   ├── catalog/
│   │   │   └── v1/
│   │   │       ├── brand.pb.go
│   │   │       ├── brand_grpc.pb.go
│   │   │       ├── product.pb.go
│   │   │       └── product_grpc.pb.go
│   │   ├── common/
│   │   │   └── v1/
│   │   │       └── common.pb.go
│   │   └── demo/
│   │       └── v1/
│   │           ├── demo.pb.go
│   │           └── demo_grpc.pb.go
│   └── protos/
│       ├── catalog/
│       │   └── v1/
│       │       ├── brand.proto
│       │       └── product.proto
│       ├── common/
│       │   └── v1/
│       │       └── common.proto
│       └── demo/
│           └── v1/
│               └── demo.proto
├── cert/
│   └── supabase/
│       └── prod-ca-2021.crt
├── cmd/
│   ├── server/
│   │   └── main.go
│   └── tree/
│       └── main.go
├── internal/
│   ├── config/
│   │   └── config.go           # github.com/ilyakaznacheev/cleanenv ile JSON parse edilmekte.    
│   ├── database/
│   │   ├── postgres.go
│   │   └── postgres_test.go
│   ├── domain/
│   │   ├── brand.go
│   │   └── product.go
│   ├── repository/
│   │   ├── dto/
│   │   │   └── product_dto.go
│   │   ├── brand_repository.go
│   │   ├── brand_repository_test.go
│   │   ├── product_repository.go
│   │   └── product_repository_test.go
│   ├── service/
│   │   ├── brand_service.go
│   │   ├── brand_service_test.go
│   │   ├── product_service.go
│   │   └── product_service_test.go
│   ├── transport/
│   │   ├── handler/
│   │   │   ├── base.go
│   │   │   ├── brand_handler.go
│   │   │   ├── demo_handler.go
│   │   │   └── product_handler.go
│   │   └── interceptor/
│   │       └── auth_interceptor.go
├── migrations/
│   ├── 000_queries.sql
│   ├── 001_initial_schema.up.sql
│   └── 002_initial_schema.down.sql
├── pkg/
│   ├── errx/
│   │   └── grpc_errors.go
│   ├── hash/
│   │   ├── otp.go
│   │   └── password.go
│   ├── i18n/
│   │   ├── en/
│   │   │   └── strings.go
│   │   └── tr/
│   │       └── strings.go
│   ├── random/
│   │   └── generator.go
│   └── text/
│       └── slug.go
├── tests/
│   ├── benchmark/
│   │   └── service/
│   │       ├── base.go
│   │       └── product_service_benchmark_test.go
│   ├── e2e/
│   │   ├── base.go
│   │   ├── brand_e2e_test.go
│   │   └── product_e2e_test.go
│   └── load/
│       ├── brand/
│       └── product/
├── scripts/
│   ├── build.sh
│   └── deploy.sh
├── deployment/
│   ├── nginx/
│   │   └── nginx.conf
│   ├── systemd/
│   │   └── grpc-backend.service
│   └── terminal commands.txt
├── Dockerfile
├── Makefile
├── README.md
├── buf.gen.yaml
├── buf.yaml
├── config.dev.json
├── docker-compose.yaml
├── go.mod
└── go.sum
