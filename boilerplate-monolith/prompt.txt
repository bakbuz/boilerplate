Golang ile gRPC tabanlı, yüksek performanslı ve düşük kaynak tüketen bir backend mimarisi tasarlamama yardımcı ol.
Aşağıdaki gereksinimlere göre mimari, dizin yapısı, modüller, config şeması, deployment adımları ve örnek kod üret:

– Dil: Go 1.25.5, minimum bağımlılık
– RPC: gRPC + Protocol Buffers
– Sunucu: AWS Free Tier EC2 (t2.micro / t3.micro) — düşük CPU/RAM için optimize
– Veritabanı: Supabase PostgreSQL (public internet erişimli)
– Şema: örnek ‘Product’ ve ‘Order’ tabloları
– Bağlantı: secure connection string, connection pooling, retry strategy
– API: CRUD servisleri (ProductService, OrderService)
– Repository pattern (interface + PostgreSQL implementation)
– Oturum: JWT veya supabase auth token
– Error handling: strongly typed; gRPC status codes
– Test: unit + integration (postgres + grpc)
– Deployment çıktı formatı: systemd servis dosyası + Go binary build adımları
– Ekstra: performans optimizasyonları, bellek tahsisi tavsiyeleri, goroutine yönetimi, connection reuse, zero-allocation gRPC handler örnekleri
– Son çıktı: proje klasör ağacı + her dosya için kısa örnek içerik + .proto dosyası + Dockerfile + Makefile + env örnekleri


--------------------------------------------------------------------------

Aşağıdaki “prompt şablonları” kaynak kodunu AI’a taratıp iyileştirme işi için en iyi sonucu verir.


You are a senior software engineer and performance/security reviewer.
I will paste source code in chunks. Analyze it end-to-end and propose improvements with a focus on: correctness, simplicity, maintainability, performance (CPU/memory/allocations), security, and observability.

Constraints:
- Keep behavior identical unless you explicitly justify a change.
- Prefer minimal dependencies and minimal diff.
- Point out hidden bugs, race conditions, edge cases, and error-handling issues.
- If you suggest refactors, provide a step-by-step plan and show the exact patches (diff format).
- Add/adjust tests for the changes.

Output format:
- Issues found (severity: critical/high/medium/low)
- Recommended changes (ranked by impact)
- Patch/diff
- Test additions
- Performance notes (expected wins, tradeoffs)




--------------------------------------------------------------------------





bir grpc backend servisinde aşağıdaki gibi bir yapı kullanmaktayım.
layered architecture kullanmaktayım. 
handler -> service -> repository -> database.
handler katmanıda grpc implementation ve hemen ardından request validation yapmaktayım.
iş mantığı ise tamamen service katmanına iletip dönen yanıtı yeniden handler katmanına döndürerek buradan reponse yapmaktayım.
bu akıştaki yanlışlarımı söyler misin? 
lütfen iyi analiz et, senden mükemmel bir yaklaşım önermeni benkliyorum.






Rolün: “Kıdemli Backend/Platform mimarı + Go/gRPC performans mühendisi + güvenlik ve test uzmanı” gibi davran. Nazik olma; yanlışları ve riskleri doğrudan söyle. Varsayım yapma: bilmediğin yerde net varsayımını belirt ve alternatifleri değerlendir.

Bağlam:
Ben bir gRPC backend servis boilerplate’i hazırladım. Layered architecture kullanıyorum:
handler (gRPC) -> service (iş mantığı) -> repository (DB erişimi) -> entity (domain model).

Mevcut akışım:

- Handler katmanında gRPC implementation var.
- Handler’da hemen ardından request validation yapıyorum.
- İş mantığını tamamen Service’e iletiyorum.
- Service’den dönen sonucu tekrar Handler’a alıp oradan response üretiyorum.

Ama handler ve service katmanları çok yakın işler yapıyormuş gibi geliyor. Bu tasarımda nerede yanlış yaptığımı ve nasıl “mükemmel” hale getireceğimi istiyorum.
Senden beklediğim çıktı formatı ve kapsam:

1.Hızlı teşhis (en kritik 10 sorun)
- Katmanların sorumlulukları karışıyor mu? Nerede?
- Handler’da validation nerede bitmeli, service’de ne başlamalı?
- “Proto → entity mapping” nerede olmalı? Ne zaman anti-pattern olur?
- Auth/CurrentUserId okuma nerede olmalı (interceptor/handler/service)?
- Transaction yönetimi (service mi repo mu?), unit-of-work ihtiyacı var mı?
- Hata yönetimi: gRPC status kodları hangi katmanda map edilmeli?
- Log/metrics/trace hangi katmanda ve nasıl?
- Repository interface tasarımı abartı mı, faydası nerede?
- DB erişim modeli (pgx/sql), connection pooling, context kullanımı riskleri.
- Performans: allocation, mapping, protobuf/JSON dönüşümleri, reflection, hot path.

2. Katman sınırları için net kurallar (kesin prensipler)
- Handler: sadece “transport adapter” mı olacak? Neyi yapmalı, neyi yapmamalı?
- Service: domain kuralları, idempotency, validation, orchestration, txn.
- Repository: query, mapping, pagination, optimistic locking, soft delete, audit.
- Database: pool, migrations, statement caching vs.

3. Önerdiğin “ideal” mimari (benim yapımdan evrimleşerek)
- Layered içinde kalarak mı iyileştireceksin, yoksa Hexagonal/Clean’e mi evriltmek mantıklı?
- Seçimini gerekçelendir: küçük proje vs büyüme, ekip, test, hız.
- Handler/Service benzerliğini bitirecek somut teknikler: DTO/Command objects, application service vs domain service ayrımı, assembler/mapper, validation pipeline, interceptors.

4. Somut refactor planı
- Adım adım: 1) küçük değişiklikler, 2) orta, 3) büyük
- Her adımın riski ve geri dönüş planı (rollback)
- Taşınacak dosya/klasör önerisi (örnek tree)
- Örnek kod iskeleti:
    - interceptor (auth + tracing)
    - handler (thin)
    - service (transaction boundary + domain validation)
    - repository (pgx)
    - error mapping (domain error -> gRPC status)

5. Kod kalite kontrol listesi (benim projeme uygulanabilir)
- Lint kuralları, test stratejisi (unit/integration), contract tests
- Observability: structured logging, metrics, traces
- Güvenlik: authn/authz, input validation, rate limiting, replay riskleri
- Performans: benchmark planı, pprof noktaları, contention ve pool ayarı

6. Benden isteyeceğin “minimum ek bilgi listesi” (ama önce varsayımlar ile cevap ver)
- DB türü, auth şekli, trafik, SLA vs.
- Bu bilgileri isterken her sorunun “neden önemli” olduğunu yaz.

Girdi:
Aşağıdaki kodları/klasör ağacını analiz edeceksin. (Ben buraya repo ağacını ve ilgili dosyaları yapıştıracağım.)

Kısıtlar:
- Dil: Go.
- gRPC + protobuf.
- Düşük kaynak (1GB RAM gibi) senaryolarında da iyi çalışmalı.
- Overengineering istemiyorum: “yeterince basit ama büyümeye hazır” hedefi.
- layered architecture

Başla:
Önce en riskli 10 problemi söyle, sonra önerdiğin ideal akışa göre bir refactor planı çıkar. Mümkün olduğunca somut ol: örnek interface’ler, error tipleri, interceptor zinciri, transaction sınırı nerede olmalı, mapping nerede olmalı.


grpc-highperf-backend/
├── api/
│   ├── gen/                         # protoc çıktıları (gitignore veya CI'de generate)
│   │   ├── catalog/
│   │   │   └── v1/
│   │   │       ├── brand.pb.go
│   │   │       ├── brand_grpc.pb.go
│   │   │       ├── product.pb.go
│   │   │       └── product_grpc.pb.go
│   │   ├── common/
│   │   │   └── v1/
│   │   │       └── common.pb.go
│   │   └── demo/
│   │       └── v1/
│   │           ├── demo.pb.go
│   │           └── demo_grpc.pb.go
│   └── protos/
│       ├── catalog/
│       │   └── v1/
│       │       ├── brand.proto
│       │       └── product.proto
│       ├── common/
│       │   └── v1/
│       │       └── common.proto
│       └── demo/
│           └── v1/
│               └── demo.proto
├── cert/
│   └── supabase/
│       └── prod-ca-2021.crt
├── cmd/
│   ├── server/
│   │   └── main.go
│   └── tree/
│       └── main.go
├── internal/
│   ├── config/
│   │   └── config.go
│   ├── database/
│   │   ├── postgres.go
│   │   └── postgres_test.go
│   ├── entity/
│   │   ├── brand.go
│   │   └── product.go
│   ├── repository/
│   │   ├── dto/
│   │   │   └── product_dto.go
│   │   ├── brand_repository.go
│   │   ├── brand_repository_test.go
│   │   ├── product_repository.go
│   │   └── product_repository_test.go
│   ├── service/
│   │   ├── brand_service.go
│   │   ├── brand_service_test.go
│   │   ├── product_service.go
│   │   └── product_service_test.go
│   ├── transport/
│   │   ├── handler/
│   │   │   ├── base.go
│   │   │   ├── brand_handler.go
│   │   │   ├── demo_handler.go
│   │   │   └── product_handler.go
│   │   └── interceptor/
│   │       ├── auth_interceptor.go
│   │       └── log_interceptor.txt
│   └── utility/
│       └── object_pool/
│           └── object_pool.go
├── migrations/
│   ├── 000_queries.sql
│   ├── 001_initial_schema.up.sql
│   └── 002_initial_schema.down.sql
├── pkg/
│   ├── errx/
│   │   └── grpc_errors.go
│   ├── hash/
│   │   ├── otp.go
│   │   └── password.go
│   ├── i18n/
│   │   ├── en/
│   │   │   └── strings.go
│   │   └── tr/
│   │       └── strings.go
│   ├── random/
│   │   └── generator.go
│   └── text/
│       └── slug.go
├── tests/
│   ├── benchmark/
│   │   └── service/
│   │       ├── base.go
│   │       └── product_service_benchmark_test.go
│   ├── e2e/
│   │   ├── base.go
│   │   ├── brand_e2e_test.go
│   │   └── product_e2e_test.go
│   └── load/
│       ├── brand/
│       └── product/
├── scripts/
│   ├── build.sh
│   └── deploy.sh
├── deployment/
│   ├── nginx/
│   │   └── nginx.conf
│   ├── systemd/
│   │   └── grpc-backend.service
│   └── terminal commands.txt
├── Dockerfile
├── Makefile
├── README.md
├── buf.gen.yaml
├── buf.yaml
├── config.dev.json
├── docker-compose.yaml
├── go.mod
└── go.sum
