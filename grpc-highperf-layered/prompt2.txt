Rol: "Kıdemli Yazılım/Platform Mimarı + Go/gRPC performans mühendisi + güvenlik ve test uzmanı" gibi davran. Nazik olma; yanlışları ve riskleri doğrudan söyle. Varsayım yapma. bilmediğin yerde net varsayımını belirt ve alternatifleri değerlendir.

Bağlam:
Düşük kaynaklı (1GB RAM gibi) sunucularda da iyi çalışan yüksek performanslı gRPC backend servis tasarlıyorum. Küçük bir ekip olduğumuzdan Layered Architecture tercih ettim.
İstemciden gelen istek akışı şöyle:
handler (gRPC) -> service (iş mantığı) -> repository (DB erişimi) -> domain.

Özellikler:
- Container/Kubernetes yok, doğrudan binary çıktı alınacak ve sunucuda private 50051 portundan çalışırken dışarıdan 443 portundan erişilecek şekilde çalışacak.
- Reflection yok
- Nginx yok. 

Mevcut akışım:

- Handler katmanında gRPC implementation var ve input validation burada yapılmakta. authentication gerekiyorsa yine burada yapılmakta. Özetle handler katmanı request, input validation, proto->entity conversion, entity->proto conversion ve grpc implementation yapmaktadır. Auth, Interceptor katmanında (Middleware) merkezi olarak çözülmekte ve Context'e inject edilmekte.
- Service katmanı iş kuralları ve yetkilendirme gerekiyorsa (authorization) burada yapılmakta. Business validation burada yapılmakta. Ayrıca iş mantığı ve audit gibi işlemler burada yapılmakta.
- Repository katmanı ise sadece DB erişimi yapmaktadır. Ayrıca pagination, optimistic locking, soft delete, transaction gibi işlemler burada yapılmakta. transaction yönetimi mevcut.
- Domain katmanı ise domain model yapmaktadır.
- Service’den dönen sonucu tekrar Handler’a alıp oradan response üretiyorum.

Bu tasarımda nerede yanlış yaptığımı ve nasıl “mükemmel” hale getireceğimi istiyorum.

Görev:
Aşağıdaki kodları/klasör ağacını analiz edeceksin.

Kısıtlar:
- Dil: Go.
- gRPC + protobuf.
- Düşük kaynak (1GB RAM gibi) senaryolarında da iyi çalışmalı.
- Overengineering istemiyorum: “yeterince basit ama büyümeye hazır” hedefi.
- layered architecture
- Memory Allocation'ı (Heap vs Stack) göz önünde bulundurarak yorum yap. Garbage Collector (GC) baskısını azaltacak struct dizilimi veya pointer kullanımı önerileri varsa belirt."

Başla:
Önce en riskli 10 problemi söyle, sonra önerdiğin ideal akışa göre bir refactor planı çıkar. Mümkün olduğunca somut ol: örnek interface’ler, error tipleri, interceptor zinciri, transaction sınırı nerede olmalı, mapping nerede olmalı.


grpc-highperf-layered/
├── api/
│   ├── gen/
│   │   ├── auth/
│   │   │   └── v1/
│   │   │       ├── auth.pb.go
│   │   │       └── auth_grpc.pb.go
│   │   ├── catalog/
│   │   │   └── v1/
│   │   │       ├── brand.pb.go
│   │   │       ├── brand_grpc.pb.go
│   │   │       ├── product.pb.go
│   │   │       └── product_grpc.pb.go
│   │   ├── common/
│   │   │   └── v1/
│   │   │       └── common.pb.go
│   │   └── demo/
│   │       └── v1/
│   │           ├── demo.pb.go
│   │           └── demo_grpc.pb.go
│   └── protos/
│       ├── auth/
│       │   └── v1/
│       │       └── auth.proto
│       ├── catalog/
│       │   └── v1/
│       │       ├── brand.proto
│       │       └── product.proto
│       ├── common/
│       │   └── v1/
│       │       └── common.proto
│       └── demo/
│           └── v1/
│               └── demo.proto
├── cert/
│   └── supabase/
│       └── prod-ca-2021.crt
├── cmd/
│   ├── server/
│   │   └── main.go
│   └── tree/
│       └── main.go
├── internal/
│   ├── config/
│   │   └── config.go
│   ├── domain/
│   │   ├── brand.go
│   │   └── product.go
│   ├── infrastructure/
│   │   ├── database/
│   │   │   ├── conn.go
│   │   │   └── conn_test.go
│   │   ├── rabbitmq/
│   │   │   └── conn.go
│   │   ├── redis/
│   │   │   └── client.go
│   │   └── storage/
│   │       └── client.go
│   ├── repository/
│   │   ├── brand_repository.go
│   │   ├── brand_repository_test.go
│   │   ├── product_repository.go
│   │   └── product_repository_test.go
│   ├── service/
│   │   ├── brand_service.go
│   │   ├── brand_service_test.go
│   │   ├── product_service.go
│   │   └── product_service_test.go
│   ├── transport/
│   │   ├── handler/
│   │   │   ├── auth_handler.go
│   │   │   ├── base.go
│   │   │   ├── brand_handler.go
│   │   │   ├── demo_handler.go
│   │   │   └── product_handler.go
│   │   └── interceptor/
│   │       ├── auth_interceptor.go
│   │       └── log_interceptor.txt
├── migrations/
│   ├── 000_queries.sql
│   ├── 001_initial_schema.up.sql
│   ├── 002_initial_schema.down.sql
│   └── 003_seed.sql
├── pkg/
│   ├── errx/
│   │   └── grpc_errors.go
│   ├── hash/
│   │   ├── otp.go
│   │   └── password.go
│   ├── i18n/
│   │   ├── en/
│   │   │   └── strings.go
│   │   └── tr/
│   │       └── strings.go
│   ├── random/
│   │   └── generator.go
│   └── text/
│       └── slug.go
├── tests/
│   ├── benchmark/
│   │   ├── base.go
│   │   ├── brand_service_benchmark_test.go
│   │   └── product_service_benchmark_test.go
│   ├── e2e/
│   │   ├── base.go
│   │   ├── brand_handler_e2e_test.go
│   │   └── product_handler_e2e_test.go
│   └── load/
│       ├── brand/
│       │   ├── list.js
│       │   └── list.sh
│       └── product/
│           ├── list.js
│           ├── list.sh
│           ├── search.js
│           └── search.sh
├── scripts/
│   ├── build.sh
│   └── deploy.sh
├── deployment/
│   ├── nginx/
│   │   └── nginx.conf
│   ├── systemd/
│   │   └── grpc-backend.service
│   └── terminal commands.txt
├── Dockerfile
├── Makefile
├── README.md
├── buf.gen.yaml
├── buf.yaml
├── config.dev.json
├── docker-compose.yaml
├── go.mod
└── go.sum
