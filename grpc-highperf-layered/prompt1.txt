Golang ile gRPC tabanlı, yüksek performanslı ve düşük kaynak tüketen bir backend mimarisi tasarlamama yardımcı ol.
Aşağıdaki gereksinimlere göre mimari, dizin yapısı, modüller, config şeması, deployment adımları ve örnek kod üret:

– Dil: Go 1.25.5, minimum bağımlılık
– RPC: gRPC + Protocol Buffers
– Sunucu: AWS Free Tier EC2 (t2.micro / t3.micro) — düşük CPU/RAM için optimize
– Veritabanı: Supabase PostgreSQL (public internet erişimli)
– Şema: örnek ‘Product’ ve ‘Order’ tabloları
– Bağlantı: secure connection string, connection pooling, retry strategy
– API: CRUD servisleri (ProductService, OrderService)
– Repository pattern (interface + PostgreSQL implementation)
– Oturum: JWT veya supabase auth token
– Error handling: strongly typed; gRPC status codes
– Test: unit + integration (postgres + grpc)
– Deployment çıktı formatı: systemd servis dosyası + Go binary build adımları
– Ekstra: performans optimizasyonları, bellek tahsisi tavsiyeleri, goroutine yönetimi, connection reuse, zero-allocation gRPC handler örnekleri
– Son çıktı: proje klasör ağacı + her dosya için kısa örnek içerik + .proto dosyası + Dockerfile + Makefile + env örnekleri


--------------------------------------------------------------------------

Aşağıdaki “prompt şablonları” kaynak kodunu AI’a taratıp iyileştirme işi için en iyi sonucu verir.


You are a senior software engineer and performance/security reviewer.
I will paste source code in chunks. Analyze it end-to-end and propose improvements with a focus on: correctness, simplicity, maintainability, performance (CPU/memory/allocations), security, and observability.

Constraints:
- Keep behavior identical unless you explicitly justify a change.
- Prefer minimal dependencies and minimal diff.
- Point out hidden bugs, race conditions, edge cases, and error-handling issues.
- If you suggest refactors, provide a step-by-step plan and show the exact patches (diff format).
- Add/adjust tests for the changes.

Output format:
- Issues found (severity: critical/high/medium/low)
- Recommended changes (ranked by impact)
- Patch/diff
- Test additions
- Performance notes (expected wins, tradeoffs)




--------------------------------------------------------------------------

Evet, kesinlikle var. Buna literatürde "Prompt Engineering" (İstem Mühendisliği) deniyor. 
Gemini (ve diğer büyük dil modelleri) ile konuşurken belirsizliği ortadan kaldırmak, alacağın cevabın kalitesini doğrudan artırır.

Verimli bir kullanım için **"R-B-G-K Formülü"**nü (Rol, Bağlam, Görev, Kısıt) uygulamanı öneririm. 

İşte bu yapının detayları:

--------------------------------------------------------------------------

Rol: Sen bir golang mühendisi ve postgresql veritabanı uzmanısın.
Bağlam: Go ile kusursuz bir BulkUpdate implementasyonu
Görev: Bu sorguyu analiz edeceksin.
Kısıtlar: yok
Başla: Üretim ortamında sorunsuz çalışan bir refactor planı çıkar


func (repo *brandRepository) BulkUpdate(ctx context.Context, list []*domain.Brand) (int64, error) {
	if len(list) == 0 {
		return 0, nil
	}

	tx, err := repo.db.Pool().Begin(ctx)
	if err != nil {
		return 0, err
	}
	defer tx.Rollback(ctx)

	// Create temp table
	_, err = tx.Exec(ctx, `
		CREATE TEMP TABLE tmp_brands_update (
			id int,
			name text,
			slug text,
			logo text,
			updated_by uuid,
			updated_at timestamp
		) ON COMMIT DROP
	`)
	if err != nil {
		return 0, errors.WithMessage(err, "failed to create temp table")
	}

	// Prepare rows for CopyFrom
	rows := make([][]any, len(list))
	for i, e := range list {
		rows[i] = []any{
			e.Id,
			e.Name,
			e.Slug,
			e.Logo,
			e.UpdatedBy,
			e.UpdatedAt,
		}
	}

	// Copy data into temp table
	_, err = tx.CopyFrom(
		ctx,
		pgx.Identifier{"tmp_brands_update"},
		[]string{"id", "name", "slug", "logo", "updated_by", "updated_at"},
		pgx.CopyFromRows(rows),
	)
	if err != nil {
		return 0, errors.WithMessage(err, "failed to copy to temp table")
	}

	// Execute Update from temp table
	cmdTag, err := tx.Exec(ctx, `
		UPDATE catalog.brands b
		SET 
			name = t.name,
			slug = t.slug,
			logo = t.logo,
			updated_by = t.updated_by,
			updated_at = t.updated_at
		FROM tmp_brands_update t
		WHERE b.id = t.id
	`)
	if err != nil {
		return 0, errors.WithMessage(err, failedToBulkUpdate)
	}

	if err := tx.Commit(ctx); err != nil {
		return 0, err
	}

	return cmdTag.RowsAffected(), nil
}